#!/bin/perl

use strict;
use warnings;
use Data::Dumper;

my $output = '';
my $clean = 0;
my $nocomments = 0;
my $noproofs = 0;
my $debug = 0;
my $folded = 0;
my $merging = 0;
my $stop_on_error = 0;
my $notoc = 0;

if(scalar(@ARGV) == 0){
    print "Not enough arguments. Type $0 -h to print help\n";
    exit;
}

my $file = $ARGV[-1];
my $filename = $file;
$filename =~ s/\.R?md$//;

print "Options : ";

for (my $i = 0; $i < scalar(@ARGV); $i++) {
    my @args;
    
    if ($ARGV[$i] =~ m/^--\w+/){
        my $arg = $ARGV[$i];
        $arg =~ s/--(\w+)/$1/;
        
        if($arg eq "no-comments"){
            print "no comments ; ";
            $nocomments = 1;
        } elsif($arg eq "no-proofs"){
            print "no proofs ; ";
            $noproofs = 1;
        } elsif($arg eq "page-merging"){
            print "page merging ; ";
            $merging = 1;
        } elsif($arg eq "no-toc"){
            print "no table of contents ; ";
            $notoc = 1;
        } elsif($arg eq "folded"){
            print "folded ; ";
            $folded = 1;
        } elsif($arg eq "stop-on-error"){
            print "stop-on-error ; ";
            $stop_on_error = 1;
        } elsif($arg eq "lesson-cards"){
            print "Making lesson card...";
            $nocomments = 1;
            $noproofs = 1;
            $folded = 1;
            $clean = 1;
            $output = "$filename-fiche.pdf";
        } else {
            print "UNKNOWN OPTION: $arg ; ";
        }
    } elsif($ARGV[$i] =~ m/^-[a-z]+/){
        my $temp = $ARGV[$i];
        $temp =~ s/-([a-z]+)/$1/;
        @args = split //, $temp;
        
        foreach my $option (@args) {
            if($option eq "o"){
                 $output = $ARGV[$i+1];
                 print "output to : $output ;";
            } elsif($option eq "c"){
                 print "clean ;";
                 $clean = 1;
            } elsif($option eq "d"){
                 print "debug enabled ;";
                 $debug = 1;
            } elsif($option eq "h"){
                 print "Parses a restricted set of Mardown marking into Latex, plus some special extensions designed to be useful when writing a math lesson in Latex.

Usage : $0 [-o output.pdf] [-c] input.md

Options :

    -h     Prints this help
    -o     Change output filename
    -c     Clean temporary files left by parser and xelatex
    -d     Prints debug output

    --no-comments   Disables comments inside document (delimited by \@\@ and \@\@)
    --no-proofs    Replaces proofs by little message saying : Go see the full lesson
    --folded       Folds pages specialy for book printing
    --stop-on-error    Stop processing file on error
    --no-page-merging  Disables page merging (2 pages on one sheet)
    --lesson-cards Equivalent to --no-comments --no-proofs --folded -c -o [filename]-fiche.pdf\n";
                 exit;
            } else {
                print "Unrecognized argument : -$option. Type $0 -h to get help\n";
                exit;
            }
        }
    }
    
}

print "\n";

my $data;
{
    open my $fh, '<', $file or die "File not found";
    local $/ = undef;
    $data = <$fh>;
    close $fh;
}


# Workaround for $$ $$
$data =~ s/\$\$/\$¶/g;

sub picture_insert{
    my $n = scalar(@_);
    
    if($n eq 0 or $n gt 2){
        return "Error while parsing image : wrong number of arguments";
    }
    my $str = "\
\\begin{figure}[h!]
\\centering
\\def\\svgwidth{\\columnwidth}
\\includegraphics[width=0.8 \\textwidth]{$_[0]}";
    if(defined($_[1])){
        $str = $str . "
\\caption{$_[1]}";
    }
    $str = $str . "
\\end{figure}";
    return $str;
}

# Pictures
if($data =~ /\n<pic(?: title="(.*)")?>([^><]+)<\/pic>/ ){
    print "Warning : <pic></pic> for inserting images is deprecated. Please use ![title](adress) as in standard Markdown\n";
}

$data =~ s/\n<pic(?: title="(.*)")?>([^><]+)<\/pic>/ł\n@{[picture_insert($2, $1)]}ł/g;

$data =~ s/\n!\[(.*)\]\(([^)]+)\)/ł\n@{[picture_insert($2, $1)]}ł\n/g;

# Encode special chars
$data =~ s/\$([^\$]*?)\$/\$@{[no_maths($1)]}\$/g;
$data =~ s/ł([^ł]*?)ł/ł@{[no_maths($1)]}ł/g;

# Workaround for \begin
$data =~ s/ł/\$ł/g;

# Little shortcut for \displaystyle
$data =~ s/þ/\\displaystyle/g;

# Special formating (code)
#$data =~ s/((?:    .+\n)+)/\$ł\\par{\\leftskip4em\\texttt $1}\\par\$ł/g;
#$data =~ s/    (.+)\n/\t$1\\\\\n/g;

####### HEADER PARSING ########
# Get title
my $title = "Document sans nom";
if($data =~ /---\n[\s\S]*title: ([^\n]+)\n[\s\S]*---/i ){
    $title = $1;
} else {
    print "Warning : no title provided. Using default : $title\n";
}
# Get author
my $author = "Antoine {\\scshape Viallon}";
if($data =~ /---\n[\s\S]*author: ([^\n]+)\n[\s\S]*---/i ){
    $author = $1;
} else {
    print "Warning : no author provided. Using default : $author\n";
}

# Get mode
my $mode = "none";
if($data =~ /---\n[\s\S]*mode: ([^\n]+)\n[\s\S]*---/i ){
    $mode = $1;
} else {
    print "Warning : no mode provided. Using default : $mode\n";
}

# Get mode
my $date = "\\today";
if($data =~ /---\n[\s\S]*date: ([^\n]+)\n[\s\S]*---/i ){
    $date = $1;
} else {
    print "Warning : no date provided. Using today's date\n";
}

# Delete everything inside --- at the begining
$data =~ s/---\n[\w\W]*?---//;

# Change 'Partie 1' to part 
#         ========
$data =~ s/\n([0-9]+)\)\s(.+)\n={3,}\n/\n\\setcounter{part}{$1}\\addtocounter{part}{-1}\\part{$2}\n/g;

# Change '# Chapitre' to chapters
$data =~ s/\n#\s+(.+)/\n\\section{$1}\n/g;

# Change '## Section' to sections
$data =~ s/\n##\s+(.+)/\n\\subsection{$1}\n/g;

# Change '### Subsection' to subsections
$data =~ s/\n###\s+(.+)/\n\\subsubsection{$1}\n/g;

# Change '#### Subsubsection' to sections
$data =~ s/\n####\s+(.+)/\n\\textbf{$1}\n/g;

# Parse definitions
$data =~ s/\n:\((.+?)\)\s+([\s\S]+?)\s\[\]/\n\\begin{definition}[$1]\n$2\n\\end{definition}/g;

# Parse propositions
$data =~ s/\n>\((.+?)\)\s+([\s\S]+?)\s\[\]/\n\\begin{proposition}[$1]\n$2\n\\end{proposition}/g;

# Parse lemmes
$data =~ s/\n>-\s+([\s\S]+?)\s\[\]/\n\\begin{lemme}\n$1\n\\end{lemme}/g;

# Parse theorems
$data =~ s/\n~\((.+?)\)\s+([\s\S]+?)\s\[\]/\n\\begin{theorem}[$1]\n$2\n\\end{theorem}/g;

# Parse remarks
if($nocomments){
    $data =~ s/\n@@\s+([\s\S]+?)\s@@/\n/g;
} else {
    $data =~ s/\n@@\s+([\s\S]+?)\s@@/\n\\begin{remarque}\n$1\n\\end{remarque}/g;
}

# Parse proofs
if($noproofs){
    $data =~ s/\n¤\s+([\s\S]+?)\s\[\]/\n\\emph{Voir preuve sur la version complète du cours}\n/g;
} else {
    $data =~ s/\n¤\s+([\s\S]+?)\s\[\]/\n\\begin{proof}\n$1\n\\end{proof}/g;
}

sub no_maths{
    my $n = scalar(@_);
    
    if($n eq 0 or $n gt 1){
        return "Error while math expression...";
    }
    my $str = "$_[0]";
    $str =~ s/(_|(?:\*{2}|[\^-]))/¬@{[ord($1)]}¬/g;
    return $str;
}

# Change '_italique_' to italic text
#$data =~ s/_([^\$\n]+?)_(?=(?:(?:[^\$])|(?:\$)[^\$]*\$)*?$)/\\emph{$1}/g; # Ce que fait cette regex de la mort est qu'elle matche tous les caractères compris entre _ et _, sauf si ces mêmes caractères sont à l'intérieur d'une expression mathématique $ $ ou $$ $$
$data =~ s/_(.+?)_/\\emph{$1}/g;

#$data =~ s/\$\$(.+?)\$\$/NotInMath($`$')/g;

# Change '**gras**' to bold text
#$data =~ s/\*{2}([^\$\n]+?)\*{2}(?=(?:(?:[^\$])|(?:\$)[^\$]*\$)*?$)/\\textbf{$1}/g;
$data =~ s/\*{2}(.+?)\*{2}/\\textbf{$1}/g;

# Put '^{texte}' in superscript
#$data =~ s/\^\{([^\$\n]+?)\}(?=(?:(?:[^\$])|(?:\$)[^\$]*\$)*?$)/\\textsuperscript{$1}/g;
$data =~ s/\^\{(.+?)\}/\\textsuperscript{$1}/g;

# Put '^[char]' in superscript
#$data =~ s/\^([^\$\n])(?=(?:(?:[^\$])|(?:\$)[^\$]*\$)*?$)/\\textsuperscript{$1}/g;
$data =~ s/\^(.)/\\textsuperscript{$1}/g;


# Put '#NUM)' in bold
$data =~ s/\n\s*([0-9]+)\)(?=(?:(?:[^\$])|(?:\$)[^\$]*\$)*?$)/\n\\par\\textbf{$1.}/g;

# Put '-' as item
$data =~ s/^\s*-\s+(.+)$/\t\\item $1/mg;
# Put items inside lists
$data =~ s/((?:\t\\item .+\n)+)/\n\n\\begin{itemize}$1\n\\end{itemize}\n/g;

sub make_table{
    my $n= scalar(@_);
    
    my @lines = split /(?<=\n)/, "$_[0]";
    
    my $ncols = 0;
    
    my $text = "";
    
    for (my $i = 0; $i < scalar(@lines); $i++){
        my @cols = split /(?<=\s\|\s)/, $lines[$i];
        my $line = "";
        for (my $j = 0; $j < scalar(@cols); $j++){
            my $temp = $cols[$j];
            $temp =~ s/((?:[^\s|] [^\s|]?)+)[\s|]*/$1/;
            $temp =~ s/ *\| ?$//;
            $temp =~ s/\n$//;
            $temp =~ s/ +$//;
            #print "Mod : $temp\n";
            $cols[$j] = $temp;
            if ($i == 0){
                $temp = "\\textbf{$temp}";
            }
            unless ($temp =~ /^-+$/){
                if ($j != 0){
                    $line = $line . " & ";
                }
                $line = $line . $temp;
            }
        }
        #print Dumper \@cols;
        if ($line ne ""){
            $text = $text . $line;
            $text = $text . "\\\\\n";
            if ($i == 0){
                $text = $text . "\\hline\n\\endhead\n";
            }
        }
        $lines[$i] = \@cols;
        $ncols = scalar(@cols);
    }
    if ($debug) {
        print "Detected table : $n\n";
        print "Lines :\n";
        print Dumper \@lines;
    }
    #print "-> ", $_, "\n" for @lines;
    my $colprint = ("|c" x ($ncols-1));
    return "\
\\begin{longtable}[h!]{|c$colprint|}
%\\centering
%\\begin{tabular}{|c$colprint|}
\\hline
$text
\\hline
%\\end{tabular}
\\end{longtable}
";
}

$data =~ s/((?:(?:.+\|(?:.+\|?)*)\n)+)/\n@{[make_table($1)]}/g;

# Shortcut for <= to \leqslant and >= \geqslant
$data =~ s/<=/\\leqslant/g;
$data =~ s/>=/\\geqslant/g;

# Shortcut for much greater and much lower
$data =~ s/>>/\\gg/g;
$data =~ s/<</\\ll/g;

# Shortcut for "implies" in texts.
$data =~ s/=>/\\ensuremath{\\Rightarrow}/g;

# Because the "standard" epsilon is ugly
$data =~ s/\\epsilon/\\varepsilon/g;

# Workaround for $$ $$ - revert
$data =~ s/\$\¶/\$\$/g;

# Workaround for \begin and \end
$data =~ s/\$ł//g;

$data =~ s/¬([0-9]+?)¬/@{[chr($1)]}/g;

### Adding header and all

my $documentclass = "";
if($merging){
    $documentclass = "a5paper, 10pt";
} else {
    $documentclass = "a4paper, 11pt";
}

my $toc = "\\tableofcontents";
if ($notoc){
    $toc = "";
}

$data = "\\documentclass[$documentclass]{article}
% Essential packages
\\usepackage{amsmath}
\\usepackage{amsthm}
\\usepackage{amssymb}
\\usepackage[french]{babel}
\\usepackage[T1]{fontenc}
\\usepackage{stmaryrd}
\\usepackage{xstring}
\\usepackage{longtable}
\\usepackage{hyperref}
\\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
} % Needed for clickable Table of contents
\\input{header.tex}
\\author{$author}
\\title{$title}
\\date{$date}
\\usepackage{xltxtra}
\\begin{document}
\\maketitle
$toc
$data
\\hrulefill


\\printendofdocument

\\end{document}";

if($output eq ''){
    $output = "$filename.pdf";
}

open(my $newfile, '>', "$filename.tex") or die "Could not open file '$filename.tex' $!";
print $newfile $data;
close $newfile;

my $print_debug = "";
my $hide_output = "2>&1";
if($debug){
    $print_debug = "1>&2";
    $hide_output = "";
}

my $cmd_end = ";";
if($stop_on_error){
    $cmd_end = "&&";
}

my $fold_command = "mv $filename.pdf $output $hide_output";

if($merging){
    $fold_command = "pdfnup $filename.pdf --nup '2x1' $hide_output; mv $filename-nup.pdf $output $hide_output";
} elsif($folded){
    print "Folded activated\n";
    $fold_command = "pdfbook --batch $filename.pdf $hide_output; mv $filename-book.pdf $output $hide_output";
}

print "Parsed file... sending to tex for processing : ";
my $shell_output;
my $xelatex_command = "";
for(my $i=0; $i<3; $i++){
    $xelatex_command = "$xelatex_command xelatex --interaction=nonstopmode $filename.tex $print_debug $cmd_end";
}
$shell_output = `$xelatex_command $fold_command`;
print "done !\n";

if($clean){
    print "Cleaning... ";
    $shell_output = `rm -f $filename.tex *.log $filename.aux $filename.toc`;
    print "done\n";
}
