#!/bin/perl

use strict;
use warnings;

my $output = '';
my $clean = 0;
my $nocomments = 0;
my $noproofs = 0;
my $debug = 0;
my $folded = 0;
my $nomerging = 0;

if(scalar(@ARGV) == 0){
    print "Not enough arguments. Type $0 -h to print help\n";
    exit;
}

my $file = $ARGV[-1];
my $filename = $file;
$filename =~ s/\.md$//;

print "Options : ";

for (my $i = 0; $i < scalar(@ARGV); $i++) {
    my @args;
    
    if ($ARGV[$i] =~ m/^--\w+/){
        my $arg = $ARGV[$i];
        $arg =~ s/--(\w+)/$1/;
        
        if($arg eq "no-comments"){
            print "; no comments";
            $nocomments = 1;
        } elsif($arg eq "no-proofs"){
            print "; no proofs";
            $noproofs = 1;
        } elsif($arg eq "no-page-merging"){
            print "; no page merging";
            $nomerging = 1;
        } elsif($arg eq "folded"){
            print "; folded";
            $folded = 1;
        } elsif($arg eq "lesson-cards"){
            print "Making lesson card...";
            $nocomments = 1;
            $noproofs = 1;
            $folded = 1;
            $clean = 1;
            $output = "$filename-fiche.pdf";
        }
    } elsif($ARGV[$i] =~ m/^-[a-z]+/){
        my $temp = $ARGV[$i];
        $temp =~ s/-([a-z]+)/$1/;
        @args = split //, $temp;
        
        foreach my $option (@args) {
            if($option eq "o"){
                 $output = $ARGV[$i+1];
                 print "; output to : $output";
            } elsif($option eq "c"){
                 print "; clean";
                 $clean = 1;
            } elsif($option eq "d"){
                 print "; debug enabled";
                 $debug = 1;
            } elsif($option eq "h"){
                 print "Parses a restricted set of Mardown marking into Latex, plus some special extensions designed to be useful when writing a math lesson in Latex.
                 
                 Usage : $0 [-o output.pdf] input.md
                 
                 Options :
                 
                 -h     Prints this help
                 -o     Change output filename
                 -c     Clean temporary files left by parser and xelatex
                 -d     Prints debug output
                 
                 --no-comments   Disables comments inside document (delimited by \@\@ and \@\@)
                 --no-proofs    Replaces proofs by little message saying : Go see the full lesson
                 --folded       Folds pages specialy for book printing
                 --no-page-merging  Disables page merging (2 pages on one sheet)
                 --lesson-cards Equivalent to --no-comments --no-proofs --folded -c -o [filename]-fiche.pdf\n";
                 exit;
            } else {
                print "Unrecognized argument : -$option. Type $0 -h to get help\n";
                exit;
            }
        }
    }
    
}

print ";\n";

my $data;
{
    open my $fh, '<', $file or die "File not found";
    local $/ = undef;
    $data = <$fh>;
    close $fh;
}


# Workaround for $$ $$
$data =~ s/\$\$/\$¶/g;

sub picture_insert{
    my $n = scalar(@_);
    
    if($n eq 0 or $n gt 2){
        return "Error while parsing image : wrong number of arguments";
    }
    my $str = "\
\\begin{figure}[H]
\\centering
\\def\\svgwidth{\\columnwidth}
\\includegraphics[width=0.8 \\textwidth]{$_[0]}";
    if(defined($_[1])){
        $str = $str . "
\\caption{$_[1]}";
    }
    $str = $str . "
\\end{figure}";
    return $str;
}

# Pictures
$data =~ s/\n<pic(?: title="(.*)")?>([^><]+)<\/pic>/ł\n@{[picture_insert($2, $1)]}ł/g;


# Encode special chars
$data =~ s/\$([^\$]*?)\$/\$@{[no_maths($1)]}\$/g;
$data =~ s/ł([^ł]*?)ł/ł@{[no_maths($1)]}ł/g;

# Workaround for \begin
$data =~ s/ł/\$ł/g;

# Little shortcut for \displaystyle
$data =~ s/þ/\\displaystyle/g;

# Special formating (code)
#$data =~ s/((?:    .+\n)+)/\$ł\\par{\\leftskip4em\\texttt $1}\\par\$ł/g;
#$data =~ s/    (.+)\n/\t$1\\\\\n/g;

# Get title
my $title = "Document sans nom";
if($data =~ /---\n[\s\S]*title: ([^\n]+)\n[\s\S]*---/i ){
    $title = $1;
} else {
    print "Warning : no title provided. Using default : $title\n";
}
# Get title
my $author = "Antoine {\\scshape Viallon}";
if($data =~ /---\n[\s\S]*author: ([^\n]+)\n[\s\S]*---/i ){
    $author = $1;
} else {
    print "Warning : no author provided. Using default : $author\n";
}

# Delete everything inside --- at the begining
$data =~ s/---\n[\w\W]*?---//;

# Change 'Partie 1' to part 
#         ========
$data =~ s/\n([0-9]+)\)\s(.+)\n={3,}\n/\n\\setcounter{part}{$1}\\addtocounter{part}{-1}\\part{$2}\n/g;

# Change '# Chapitre' to chapters
$data =~ s/\n#\s+(.+)/\n\\section{$1}\n/g;

# Change '## Section' to sections
$data =~ s/\n##\s+(.+)/\n\\subsection{$1}\n/g;

# Change '### Subsection' to subsections
$data =~ s/\n###\s+(.+)/\n\\subsubsection{$1}\n/g;

# Change '#### Subsubsection' to sections
$data =~ s/\n####\s+(.+)/\n\\textbf{$1}\n/g;

# Parse definitions
$data =~ s/\n:\((.+?)\)\s+([\s\S]+?)\s\[\]/\n\\begin{definition}[$1]\n$2\n\\end{definition}/g;

# Parse propositions
$data =~ s/\n>\((.+?)\)\s+([\s\S]+?)\s\[\]/\n\\begin{proposition}[$1]\n$2\n\\end{proposition}/g;

# Parse lemmes
$data =~ s/\n>-\s+([\s\S]+?)\s\[\]/\n\\begin{lemme}\n$1\n\\end{lemme}/g;

# Parse theorems
$data =~ s/\n~\((.+?)\)\s+([\s\S]+?)\s\[\]/\n\\begin{theorem}[$1]\n$2\n\\end{theorem}/g;

# Parse remarks
if($nocomments){
    $data =~ s/\n@@\s+([\s\S]+?)\s@@/\n/g;
} else {
    $data =~ s/\n@@\s+([\s\S]+?)\s@@/\n\\begin{remarque}\n$1\n\\end{remarque}/g;
}

# Parse proofs
if($noproofs){
    $data =~ s/\n¤\s+([\s\S]+?)\s\[\]/\n\\emph{Voir preuve sur la version complète du cours}\n/g;
} else {
    $data =~ s/\n¤\s+([\s\S]+?)\s\[\]/\n\\begin{proof}\n$1\n\\end{proof}/g;
}

sub no_maths{
    my $n = scalar(@_);
    
    if($n eq 0 or $n gt 1){
        return "Error while math expression...";
    }
    my $str = "$_[0]";
    $str =~ s/(_|(?:\*{2}|[\^-]))/¬@{[ord($1)]}¬/g;
    return $str;
}

# Change '_italique_' to italic text
#$data =~ s/_([^\$\n]+?)_(?=(?:(?:[^\$])|(?:\$)[^\$]*\$)*?$)/\\emph{$1}/g; # Ce que fait cette regex de la mort est qu'elle matche tous les caractères compris entre _ et _, sauf si ces mêmes caractères sont à l'intérieur d'une expression mathématique $ $ ou $$ $$
$data =~ s/_(.+?)_/\\emph{$1}/g;

#$data =~ s/\$\$(.+?)\$\$/NotInMath($`$')/g;

# Change '**gras**' to bold text
#$data =~ s/\*{2}([^\$\n]+?)\*{2}(?=(?:(?:[^\$])|(?:\$)[^\$]*\$)*?$)/\\textbf{$1}/g;
$data =~ s/\*{2}(.+?)\*{2}/\\textbf{$1}/g;

# Put '^{texte}' in superscript
#$data =~ s/\^\{([^\$\n]+?)\}(?=(?:(?:[^\$])|(?:\$)[^\$]*\$)*?$)/\\textsuperscript{$1}/g;
$data =~ s/\^\{(.+?)\}/\\textsuperscript{$1}/g;

# Put '^[char]' in superscript
#$data =~ s/\^([^\$\n])(?=(?:(?:[^\$])|(?:\$)[^\$]*\$)*?$)/\\textsuperscript{$1}/g;
$data =~ s/\^(.)/\\textsuperscript{$1}/g;


# Put '#NUM)' in bold
$data =~ s/\n\s*([0-9]+)\)(?=(?:(?:[^\$])|(?:\$)[^\$]*\$)*?$)/\n\\par\\textbf{$1.}/g;

# Put '-' as item
$data =~ s/^\s*-\s+(.+)$/\t\\item $1/mg;
# Put items inside lists
$data =~ s/((?:\t\\item .+\n)+)/\n\n\\begin{itemize}$1\n\\end{itemize}/g;

# Shortcut for <= to \leqslant and >= \geqslant
$data =~ s/<=/\\leqslant/g;
$data =~ s/>=/\\geqslant/g;

# Workaround for $$ $$ - revert
$data =~ s/\$\¶/\$\$/g;

# Workaround for \begin and \end
$data =~ s/\$ł//g;

$data =~ s/¬([0-9]+?)¬/@{[chr($1)]}/g;

### Adding header and all

my $documentclass = "";
if(!$nomerging){
    $documentclass = "a5paper, 10pt";
} else {
    $documentclass = "a4paper, 11pt";
}

$data = "\\documentclass[$documentclass]{article}
\\input{header.tex}
\\author{$author}
\\title{$title}
\\date{\\today}
\\usepackage{xltxtra}
\\begin{document}
\\maketitle
\\tableofcontents
$data
\\hrulefill


\\printendofdocument

\\end{document}";

if($output eq ''){
    $output = "$filename.pdf";
}

open(my $newfile, '>', "$filename.tex") or die "Could not open file '$filename.tex' $!";
print $newfile $data;
close $newfile;

my $print_debug = "";
my $hide_output = "2>&1";
if($debug){
    $print_debug = "1>&2";
    $hide_output = "";
}

my $fold_command = "mv $filename.pdf $output $hide_output";

if(!$nomerging){
    $fold_command = "pdfnup $filename.pdf --nup '2x1' $hide_output; mv $filename-nup.pdf $output $hide_output";
} elsif($folded){
    print "Folded activated\n";
    $fold_command = "pdfbook --batch $filename.pdf $hide_output; mv $filename-book.pdf $output $hide_output";
}

print "Parsed file... sending to tex for processing : ";
my $shell_output;
my $xelatex_command = "";
for(my $i=0; $i<3; $i++){
    $xelatex_command = "$xelatex_command xelatex $filename.tex $print_debug;";
}
$shell_output = `$xelatex_command $fold_command`;
print "done !\n";

if($clean){
    print "Cleaning... ";
    $shell_output = `rm -f $filename.tex *.log $filename.aux $filename.toc`;
    print "done\n";
}
